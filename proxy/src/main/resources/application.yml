#application.yml

server:
  port: 8081 # Puerto donde correrá el proxy-service. No interfiere con el backend (8080).

spring:
  application:
    name: proxy-service # Nombre interno de la aplicación

  data:
    redis:
      host: ${REDIS_HOST:192.168.194.250}   # Host de Redis remoto (inyectado por .env). Si no existe, usa 192.168.194.250.
      port: ${REDIS_PORT:6379}              # Puerto de Redis (por defecto 6379).

  kafka:
    bootstrap-servers: ${KAFKA_BROKER:192.168.194.250:9092}  # Servidores Kafka. Si .env no existe, usa el de la cátedra.
    consumer:
      group-id: ${PROXY_GROUP_ID:grupo-alumno}  # Cada alumno debe tener un groupId único para leer Kafka sin interferencias.
      auto-offset-reset: earliest               # Si nunca consumió, empieza a consumir desde el primer mensaje disponible.
    listener:
      missing-topics-fatal: false               # Si el topic no existe todavía, no rompe la aplicación.

catservice:
  url: ${CAT_SERVICE_URL:http://192.168.194.250:8080/api}  # URL base del servidor de la cátedra. Usado para leer eventos.

catedra:
  jwt-token: ${CATEDRA_JWT_TOKEN:}

logging:
  level:
    # Nivel de logs global de la aplicación.
    root: INFO # INFO muestra solo información importante (no incluye DEBUG).

    # Evita que Spring Security llene la consola con logs técnicos.
    org.springframework.security: INFO # Muestra solo advertencias y eventos importantes.

    # Filtro ProxyTokenAuthFilter en DEBUG para ver:
    # - si llega el Bearer
    # - si falta el token
    # - qué ruta está siendo filtrada
    ar.edu.um.proxyservice.config.ProxyTokenAuthFilter: DEBUG #INFO

    # Logs del KafkaListener (eventos recibidos).
    # INFO muestra solo los mensajes reales de Kafka, sin debug interno.
    ar.edu.um.proxyservice.messaging: INFO

    # Kafka produce MUCHÍSIMOS logs si está en INFO.
    # Lo dejamos en WARN para mostrar solo advertencias/errores reales.
    org.apache.kafka: WARN

